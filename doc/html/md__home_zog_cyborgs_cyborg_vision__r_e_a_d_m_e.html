<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FRC #4221 Joliet Cyborgs Computer Targetting and Ranging: Autonomous-related code for FRC #4241 autonomous operation efforts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FRC #4221 Joliet Cyborgs Computer Targetting and Ranging
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Autonomous-related code for FRC #4241 autonomous operation efforts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>One of the key aspects to creating a solution for autonomous control (or for any sort of complex system really) is to develop a strategy to manage, coorelate, and analyze information from a number of different sources.</p>
<p>The goal here is to give the robot a sense of situational awareness potentially including:</p>
<ul>
<li>Location</li>
<li>Distances from other objects</li>
<li>Orientation to other objects and general playfield</li>
</ul>
<p>With this information, the robot has the potential to be able to perform non-trivial high-level tasks without human intervention. This is a continous process often refered to as an "**OODA loop*:</p>
<ul>
<li><b>O</b> - Observe (what is around the robot?)</li>
<li><b>O</b> - Orient (how is the robot oriented in regards to its observed surroundings?)</li>
<li><b>D</b> - Decide (what should the robot do? As in <em>now</em>; turn, move, lift, drop, shoot, etc.? This probably is and should be part of a bigger goal.)</li>
<li><b>A</b> - Act (how should the robot instantiate its decision?)</li>
<li>Repeat...</li>
</ul>
<p>Each of these is a discrete step in the autononmous process and is repeated over and over with updated inputs and goals as appropriate. This is not an easy to reach goal.</p>
<p>One of the first challenges is the collection and management of this informaton which may be coming from a significant number of individual sensors and other data sources. Maintaining the timeliness of this information is key - much of the robots actions will be driven by very near term observations of its surroundings, likely limited to a few seconds of history (at most, maybe even less). To this end, the core of the autonomous system is the database of sensed information and providing a set of ways to analyze, normalize (if needed), and make this raw or conditioned information available to the robot control logic (which could reside on or off the RoboRio).</p>
<p>This a longer term and more comprehensive approach - it might yield payoffs in the short term (I feel we can use the information even for a simple robot control scenario) but it also provides an architecture for a longer term and more sophisticated method of awareness and subsequent control.</p>
<p>The architecture is designed around a series of functional blocks which should give the ability to modify, replace, and re-work substantial components with minimal impacts on other parts of the system. Each component can be thought of as having a specific responsibility with connections to and from other components over which data and commands move between functional blocks. Looking at the system in that way can make it easier to understand the overall approach without having to dig into the details of implementation of any individual component.</p>
<p><b>Note:</b> This is an evolving document and is trying to be maintained as the thinking about this approach is evolving as well. You might see repetition or even contradictions; excuse the first but please point out the second.</p>
<h2>Overview</h2>
<p>Architecture is a set of servers collecting information (such as cv_cam for each camera that watches the serial camera output) and sending the sensor data via a UDP packet to the centralized database (cv_db). In the case of a camera, each cv_cam modules passes robot object and visual field location information to cv_db as well as some identifying information tying this visual information to a specific camera. Similar processing happens for other sensors (like ultrasonic rangers for example).</p>
<p>The database maintains lists per sensor with some extra structure for cameras (such as names of identified object with visual coordinate-based values for each record) Each record is timestamped to sub-millisecond precision so we know precisely when it arrived and was stored. In the case of cameras, this creates a time-based sequence of camera records maintained for each object the cameras report; other sensors are logged in the same way. A separate thread prunes the lists based on an overall Time-To-Live (TTL) value to remove old records but still allow access to the latest information from each camera (and potentially other sensors) as well as an averaged set of values based on the TTL.</p>
<p>Another thread responds to querys about the data base to provide up-to-date information about the spatial environment around the robot. Queries could include:</p>
<ul>
<li>Does any camera see the "ball" object?</li>
<li><p class="startli">How far away from an obstacle is the front sensor of the robot?</p>
<p class="startli">This thread will typically communicate with the cv_robo module.</p>
</li>
</ul>
<p>A third component (cv_robo) will communicate with cv_db and work with the robot code to steer, drive, and otherwise operate the robot based on visual cues. Cv_robo will act just like a human-operated joystick and move the robot and actuate the appropriate functions based on visual cues (just like a human operator would). The actual robot driving logic lives here.</p>
<p>The overall system is designed to operate around at least a pair of JeVois smart cameras using both the CLI API to control and configure the cameras and the serial output providing object-based information. Overall, the system is fairly independent of the visual processing strategy used so we can delay choosing a visual processing algorithm until we understand the challenge and can even it change it while wr're working on the roboto or even between events or runs if we are feeling especially bold and confident). There may be other sensors use to augment the robot's perception of its environment and its orientation to the field of play and the contents thereof.</p>
<h2>Architecture</h2>
<p>Below is a diagram showing the relationship and connectivity of major parts of the vision-processing system. Keep in mind that this can grow to be more than just vision; the goal is autonomous operation of the robot and while it's believed that vision is going to play a key role in this, it's also very likely that the robot is going to end up growing some sort of "sensor package" to help it get the job done.</p>
<div class="image">
<img src="https://github.com/cgzog/cyborg_vision/blob/master/cv_arch_diagram.png" alt="Cyborg-vision Architectural Diagram" title="Cyborg-vision Architectural Diagram"/>
</div>
<h3>Components</h3>
<h4>Device Servers</h4>
<p>These are small, special purpose processes that in general watch a sensor, get it's current readings (either on a regular interval or whenever the sensor sends it out depending on the behavior of the sensor).</p>
<p>They take these values, add some identification information, and send it to the CV Database for logging.</p>
<h5>Camera Servers</h5>
<h5>Other Sensor Servers</h5>
<p>The design does not preclude having more sensor servers which can monitor individual or sets of sensors and pass that information to cv_db. This could include different sensor types such as ultrasonic, light or others sensor types.</p>
<p>Each sensor type can have its value stored in same time-tracked manner as the cameras making the most recent values available to the Robot Driver module for consideration in cotrolling the robot. The format of the data from each sensor type can be defined at the time that sensor is incorporated taking into account the type and richness of the information available from that sensor type. Each data record will need to include the appropriate sensor identification information so that each specific sensor instance can be mapped into the physical space surrounding the robot.</p>
<p>The diagram includes a 9-way combination sensor including:</p>
<ul>
<li>3-axis accelerometer</li>
<li>3-axis magnetometer</li>
<li>3 axis rotation</li>
</ul>
<p>This information will be logged in the same manner as any other sensor with the hope of being able to recover actual robot movments and forces post-practive and post-competition.</p>
<p>It may also send measurement to cv_db to make them available to the robot controlling logic.</p>
<h4>Database</h4>
<p>The Cyborg-Vision Database (cv_db) gets readings from various sensor servers and saves their values. In addition to saving the values, it also regularly "prunes" the database to remove older values (typically referred to as a TTL, or **T**ime-**t**o-**L**ive). Whenever it finds values older than the TTL limit, it removes these from the database. Think of it terms of keeping only the most recent sensor history; who cares what a camera saw 30 seconds ago? The robot has probably moved, turned, or something else has changed; we mostly want to know what's happening right now (or at least within only the last few seconds). This database is essentially an enhanced "Last Value" cache ("Last Few Values" essentially) and will be retained fully in memory (so it will be lost when the robot powers down). It will however log all incoming data messages and queries for later reference.</p>
<p>Processes that want to find out about the conditions around the robot (whether visual, ranging, etc.) can query cv_db and get the status of a specific sensor, a set of sensors, or potentially even an average sensor reading across the values available.</p>
<p>Here is a high level diagram showing how the various structures that correspond to the different sensors are stored and how the data is related to it's associated sensor (which generally provides the context for the data in terms of where this data applies in terms of it's relatonship with the robot:</p>
<div class="image">
<img src="https://github.com/cgzog/cyborg_vision/blob/master/sensor_db_structure.png" alt="Cyborg-vision Sensor Data Storage Diagram" title="Cyborg-vision Sensor Data Storage Diagram"/>
</div>
<h4>Robot Driver</h4>
<p>The Robot Driver (cv_robo) essentially emulates the actions of a human robot operator. It queries the cv_proc module for appropriate sensor status to get information useful to detecting potential targets, aligning the robot to interact with them, and establish its orientation with the surrounding field of play.</p>
<p>This will probably be the most complex part of the vision-processing system as it is responsible for mapping this information into the actions a human operator would use to move and actuate the robot. The programming team will need to work closely with the drive team in order to understand how to effectively move, steer, and otherwise operate the robot.</p>
<p>The interface to the RoboRIO will be through a serial port. There will need to be some new code resident on the RoboRIO to interpret commands coming from the cv_robo module and interpret them just like human-generated joystick commands for operating the robot. There are a few key aspects to consider here:</p>
<ul>
<li>The command handling module will need to be modified to accept direct commands from the cv_robo module as well as the current joystick interface</li>
<li>The RoboRIO will need to know when autonomous mode is active or not at any given time<ul>
<li>Autonomous Start: Indicate to the cv_robo module that it should start controlling the robot.<ul>
<li>Until this time, the vision-processing system can be running and actively scanning the robot's surroundings</li>
<li>Any potential or incorrect targets detected before the start of autonomous mode can either be explicitly purged from the vision-processing system once the "Start of Autonomous Mode" signal is given to the cv_robo modules</li>
<li>Any potential or incorrect targets detected before the start of autonomous modeAutonomous Active: Accept command from cv_robo only at this time and ignore other command inputs</li>
</ul>
</li>
<li>Autonomous Inactive: Accept only human-generated inputs and ignore any commands from the cv_robo module<ul>
<li>Whether or not the cv_robo module needs to be told that autonomous mode is no longer active is something that can be decided later</li>
<li>It seems there would be no negative side effects if the vision-processing system continues to operate during the competition and logs objects it sees as well as other sensor inputs as these might be useful for later analysis</li>
<li>One big advantage for keeping the autonomous system active is the ability to provide what could be considered "augmented control" - the ability to have some smaller sets of operations happen autonomously even during human-controlled operation. As an example, there could be an operational mode where the robot advances on a target object or location until it is some sensed distance away from it, and then automatically perform some operation (like drop or pick up something). The advantage for a capability like this is it could make some potential operations more reliable by eliminating the need to specific robot positioning or interactions by having the robot itself handle the final, close-in details of some interaction. Another example could be align the robot with a target, get a distance measurement, and then adjust it's operation with minima human operation (shooting a ball towards a target is an example of this; the robot can be coarsely aligned by the human operation who can initiate a series of operations where the robot does a more fine grained alignment and adjusts the power of it's action in order to accomodate the distance to the target.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5>Robot Driver Fallback Approach</h5>
<p>If we can't get the logic to control the robot the level we like in the Robot Driver module, we can fallbck to making the sensor data available directly to the Robo Rio. In this case, the autonomous system is reduced to a sensor database that provides sets of sensor data to the main robot controller.</p>
<h4>Visual Status Display</h4>
<p>This module, cv_status, drives a series of human-visible LEDs on the robot that display the status of different components of the visual-processing system. This will provide a way for the components in the autonomous system to report various status and states via RGB LEDs driven by the cv_status server (and supporting hardware driver) providing immediate visual feedback on the operation of the autonomous system.</p>
<p>This can provide visual feedback to an observer as to the status and operation of the visual-processing system. All of the different components can send messages to cv_status to control their respective indicators.</p>
<h3>Hardware platform and Environment</h3>
<h3>Other ideas and considerations</h3>
<h4>Logging and Tracing</h4>
<p>It will be important for each component in the vision-processing system to record information so that post-testing or post-competition, we can analyze how well it worked and potentially improve it for future runs.</p>
<p>This information could include:</p>
<ul>
<li>Configuration settings for each component</li>
<li>Messages sent and received from other components of the vision-processing system</li>
<li>Key logic decisions impacting the decisions and operations while in autonomous mode</li>
</ul>
<p>All of this information would need to be timestamped so it can be later correlated and analyzed to get a complete picture of the operation of the vision-processing system. Syncronization of timestamps between different components should not be a problem since all of the vision-processing system will be running on a single hardware platform supplying the exact same timebase to all components.</p>
<p>The logging and tracing information should be stored as text rather than binary to allow a programmer to quickly be able to scan through and understand the output without much additional processing. This doesn't mean that we might not want to create other tools to help us correlate or otherwise visualize the vision-processing logs to better understand how it is operating.</p>
<p>There are a few key considerations to make this work well:</p>
<ul>
<li>We need make sure that the log survives the robot powering off at the end of the competition (unless we can maintain power to the hardware supporting the log-supporting device from before the practice or competiion starts until we access the log)</li>
<li>If we will lose power, we need to ensure that the log records are not damaged by the log-supporting device losing power. We can take some steps to try and minimize the chances of this and try to make things record log information as synchronously as we can.</li>
</ul>
<p>We need to extend this to the Robo Rio-based control code as well. If possible, we should timestamp and log each command input from the human operators for later review and use as test data for a further robot testing and debugging.</p>
<h4>Visual Tracing</h4>
<p>In addition to logging vision-processing statuses, events, and activity in the log files, it might be useful to include a set of visible indicators on the robot in order to give real-time information about what the vision-processing system is doing at that moment in time. The Raspberry PI B+ platform provides 20+ GPIO pins (**G**eneral **P**urpose **I**nput/**O**utput) which could be used to drive a series of LEDs on the robot indicating information about what is happening.</p>
<p>Each major component could be associated with an appropriate set of LEDs that could indicate appropriate status information such as:</p>
<ul>
<li>That module has started and is operating</li>
<li>Specific processing indications like certain read, write, or computational events</li>
<li>Heartbeats indicating some component is still running.</li>
</ul>
<h4>Physical Recording</h4>
<p>During testing and competition activities, it would be very useful to record the robot from several different locations to capture how it physically controls the robot. If possible, this should be done in a manner that captures the robot in slow motion for more detailed analysis of the physical movements of the robot as well as capturing any Visual Tracing indications.</p>
<h4>Post-practice and post-competition procedures</h4>
<p>We should include as part of the post practice or competition checklist the task of downloading, saving, and uploading the logs. This will make sure that we have them available and saved and also allow a remote team member to review and work with the on-site team members to potentially help understand a problem or other anomoly.</p>
<p>This probably should be one of the very first things we do even before fixing a broken or damaged robot; it will only take a few moments (we'll need to work out our procedures to they'll be fast, safe for the logged data, and well documented).</p>
<p>The example is a Formula One racing team; data is one of the most valuable to things to get from the car each time it goes out and gets taken care of before anyone even starts wrenching on it.</p>
<h4>General Autonomous Hardware Philosophy</h4>
<p>There will be a lot of moving parts here - software and hardware. To give us the ability to have reasonable spares on hand and the ability to put those spares into play quickly and reliably, we need to take a little care as to how the system gets configured and connected. Ideally we will want a system implementation that will allow us to setup and validate major devices back at the shop and be able to replace a failing component with no or minimal (and super clear and super documented) configuration.</p>
<p>If it takes a bunch of software programming or at worst, actual changes to the code for something, in order to get it configured, the likelyhood of an error or mistake under pressure goes <em>way</em> up. Once we validate something, we need to be able to bag it and stash it as a spare without messing around with it any more than we absolutely have to.</p>
<p>That said, we'll want to make sure that we bring the right equipment to be able to maintain and work on the autonomous components if needed during a competition. In those sorts of high-pressure situations, we will need to have well documented and practiced procedures to make sure we stay in control, don't make things worse through not knowing what code something is running or what it's configuration should be, don't lose changes or improvements, and similar considerations.</p>
<p><b>At the end of the day, it's not just what you do but how you do it so that you can do it again - reliably and repeatably!</b></p>
<h2>Key programming concepts to know to understand the code</h2>
<p>For maximum portability and control, the bulk of the software is written in C. There are several concepts that are important to know in order to understand and modify the code.</p>
<p>These include:</p>
<h3>#define</h3>
<p>Understanding the #define directive is an important part in creating readable and maintainable code. This is really part of a while family of directives including things like #ifdef, #ifndef, #else, #endif, and others. Good use of these directives gives you the ability to change your code with a compile-time directive (like enabling specific deep debugging output or accommodating platforms differences through platform-specific code for example).</p>
<p>They also provide an effective way to define various constants used in your code in a good human-readable way so you'll very often see them used in that capacity. For example, the cv_proc module is intended to support two (2) cameras and the code takes that into account. It's obvious that there are some parts of the code that need to be aware of that fact. You could just use the hard-coded value "2" in these places sort of like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> placeToPutStuff[2];</div></div><!-- fragment --><p>In this case, it's hard to know why there this array has 2 elements. Consider this as an alternative:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NUM_OF_CAMERAS</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> placeToPutStuff[NUM_OF_CAMERAS];</div></div><!-- fragment --><p>Without even seeing more than that, it's obvious that this is related to number of cameras defined. Imagine wanting to change the code from supporting 2 cameras to 3 cameras; it's easy to update the NUM_OF_CAMERAS #define and change it from 2 to 3 and have a lot of data structures be updated accordingly. Otherwise you're left trying to figure out what that "2" means; is it the number of cameras or just something else in the code that there happen to be two of?</p>
<p>In addition, you'll also see them used as a macro for some code that you don't want to put in a separate function but want to be expanded in-line right in the code without repeating it over and over. With a #define, you can "define" it once and easily incorporate it where needed - the Camera List data structure lock and unlocking code is a good example of this in the cv_proc code.</p>
<p>Some links:</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/cc-preprocessors/">C/C++ Preprocessors</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/teas0593(v=vs.140)">#define Directive (C/C++)</a></li>
</ul>
<p>As a point of information, the term "preprocessor" refers to the compiler pass that first handles all of the #defines and other #something directives before the code is compiled. Historically this was done by a separate program called the, wait for it, the "preprocessor" though this behavior is built-into many modern compilers (but usually there is an option to see the "pre-processed" code where you can see the code with all of the preprocessor changes which is very handy for debugging more complicated macro definitions.</p>
<h3>Structures and Typedefs</h3>
<p>Structures are a key way in C and C++ to group related variables together. The combine multiple variables into a data entity that can be stored, passed around in the code, and manipulated in a way that maintains the relationships between the variables there in.</p>
<p>For example, a structure in the vision code could look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>iSeeYou {</div><div class="line">    <span class="keywordtype">char</span> thingISee[100];   /  name of the thing I see</div><div class="line">    <span class="keywordtype">int</span>  x;                <span class="comment">// x coordinate in the camera&#39;s view</span></div><div class="line">    <span class="keywordtype">int</span>  y;                <span class="comment">// y coordinate in the camera&#39;s view</span></div><div class="line">}</div></div><!-- fragment --><p>This creates a new data type which can be referenced just like a more basic data type - for example, we could declare an array those structures like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>iSeeYou thingsSeen[20];</div></div><!-- fragment --><p>There is a specific syntax to deal with these items - below is an example where we set the X coordinate of the 5th item to 12345:</p>
<div class="fragment"><div class="line">thingsSeen[4].x = 12345;    <span class="comment">// remember, arrays start at 0!</span></div></div><!-- fragment --><p>Typedefs are a lot like structure definitions but they allow us to actually define a new data type - let's use the above example and create a new data type STUFF_SEEN:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <span class="keywordtype">char</span> thingISee[100];   /  name of the thing I see</div><div class="line">    <span class="keywordtype">int</span>  x;                <span class="comment">// x coordinate in the camera&#39;s view</span></div><div class="line">    <span class="keywordtype">int</span>  y;                <span class="comment">// y coordinate in the camera&#39;s view</span></div><div class="line">} STUFF_SEEN;</div></div><!-- fragment --><p>This looks a lot like the original structure but we can use it much easier in the code - for example, here's a declaration of a variable of this new type:</p>
<div class="fragment"><div class="line">STUFF_SEEN  hey;</div></div><!-- fragment --><p>More details at:</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/structures-c/">Structures in C</a></li>
<li><a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">Struct (C programming Language)</a>)</li>
<li><a href="https://www.tutorialspoint.com/cprogramming/c_structures.htm">C - Structures</a></li>
</ul>
<h3>Pointers</h3>
<p>Pointers are a way to efficiently access memory locations corresponding to variables and structures when using C. Pointers allow efficient access by "pointing" to code to locations of variables and structures rather than passing entire structures around. The use of pointers also supports more sophisticated and flexible data structures such as linked lists which in some usages are much more flexible and powerful than arrays (as one example). Understanding the use of pointers and the processing associated with pointer arithmetic is a requirement for almost any non-trivial C programming effort.</p>
<p>Many system and library calls use pointers to pass or return structures so it is very important to have this understanding to make best use of the system call and utility library functions.</p>
<p>Here links to some information sources that can help explain pointers:</p>
<ul>
<li><a href="http://www.circuitstoday.com/introduction-to-pointers-in-c">Introduction to pointers in C</a></li>
<li><a href="https://www.go4expert.com/articles/introduction-pointers-c-t27959/">Introduction to pointers in Ci (seems to be a popular title for this topic)</a></li>
<li><a href="https://www.youtube.com/watch?v=h-HBipu_1P0">Introduction to pointers in C/C++ (video)</a></li>
</ul>
<h3>Linked Lists</h3>
<p>Linked Lists are a key basic data structure. Pointers are the easiest (not the only but by far the easiest) way to implement linked lists. Linked lists provide a flexible mean to connect data records in a way where they can be added, deleted, or reordered without moving large amounts of data by simply changing a few pointers.</p>
<p>Here are a few resources to get you up to speed on linked lists:</p>
<ul>
<li><a href="https://www.zentut.com/c-tutorial/c-linked-list/">C Linked List</a></li>
<li><a href="https://www.codeproject.com/articles/641175/%2fArticles%2f641175%2fAn-Introduction-to-Linked-Lists-in-C-Cplusplus">Introduction to Linked Lists in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/linked-list-set-1-introduction/">Linked List Introduction</a></li>
</ul>
<h3>System and Library Calls</h3>
<p>These are the basic calls to get the operating system to do something for us - open a file, get us some more memory, kill something that's running, etc. System calls are the most basic functionality the operating system (Linux, Windows, etc). can provide - you get the most control but at times they can be harder to use. There are environments that have a very minimal (or maybe even no operating system) like an Arduino, a set of pretty basic routines (like the RoboRio) or a full tilt, crankin' it out operating system like Linux (a Raspberry Pi is a good example of that).</p>
<p>Library calls will look very similar and often times cause the operating system to do something as well. Things that fall into that category are routines like stdio (C) or iostream (C++); these sorts of routines provide an easier to use or more flexible and hide some of the system call complexity (stdio and iostream are perfect examples of that). They'll also provide functionality that many programs want to use like string manipulation that while they aren't things the operating system cares about ("I'm an 'OPERATING SYSTEM' friend - I don't do string comparison!").</p>
<p>There are a lot of function calls that fall into these areas - 100's at least (at one point I knew pretty much all of them but a lot of water has flowed under the bridge and a lot of routines have been added so that's probably not the case anymore). So how do you get started? I'd start by looking at the code and using one of the good "manpage" sites online ("manpage" is short for manual page so you won't sound like you're not hip to the groove that's being laid down).</p>
<p>A good site for Linux manpages is <a href="http://man7.org/linux/man-pages/dir_all_alphabetic.html">Man7.org</a>.</p>
<p>Manpages will have standard set of sections that will you understand what's happening - for system and library calls, you'll typically see:</p>
<ul>
<li><b>Name</b></li>
<li><b>Synopsis</b> (function name, parameters, and return types - if you know what you are doing, a lot of times this is all you need to jar your memory)</li>
<li><b>Description</b> (the will provide more information on what it does and what the parameters or options are if it's not totally obvious)</li>
<li><b>Return Value</b> (what you get back if it works as well as if it doesn't work)</li>
<li><b>See Also</b> (cross references to other related functions - the page to "open" something probably has a link to the functions to "close" it or otherwise manipulate it so if you just remember one name, you can get connected to the other complimentary functions just about every time)</li>
</ul>
<p>You'll notice there are numbers involved (we never said there would be no math!); these numbers mean things. The numbers 2 and 3 are probably the most interesting to software developers as those identify system calls and library functions respectively - these are functions your program can actually call. Things with number 1 are commands - things you'd type at the Linux command prompt to do something other than calling a function in your program.</p>
<p>Here are a few examples:</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man3/string.3.html">string(3)</a> - various C string functions (there are quite a few)</li>
<li><a href="http://man7.org/linux/man-pages/man1/cp.1.html">cp(1)</a> - command to copy files and directories; lots of options in the "Description" section</li>
</ul>
<h3>Memory Management</h3>
<p>Many programming languages relieve the programmer from having to manage memory - that is the need to get memory to put new data and objects into and the need to dispose of it when it's no longer needed (not disposing of unneeded memory is generally considered a bug; at best your application will just keep growing but at worst, you'll overwrite or discard the pointer needed to free memory and create what is considered a "memory leak" - these are not considered a feature). The languages that do this automatically are typically referred to as supporting <em>automatic garbage collection</em>; Java is one of those, C isn't.</p>
<p>In C, you allocate memory using the <a href="https://linux.die.net/man/3/malloc">malloc</a>() function to get more memory (think of it as shorthand for **m**emory **alloc**ation). This function will make a certain amount of memory available to the program for use. This memory can be used to store anything, any type of data, for as long as you need to store or (or at least until your program exits at which point any memory used by it it released so it's not lost <em>forever</em> ;). Malloc() returns a pointer if successful; otherwise it returns 0 (or a NULL pointer in the parlance of C). This is something your program wants to check for just to make sure something awful hasn't happened. The vision processing system has it's malloc() call in <a class="el" href="utility_8c.html">utility.c</a> and is wrapped by a function called <a class="el" href="utility_8c.html#a1716a2f1dbfb9632f89d75a83b017ed7" title="cyborg vision malloc front end ">cvAlloc()</a>. If a memory allocation ever fails, it's likely that the situation not just for your program, but potentially for the whole system is, well, grim. There isn't a lot you would typically do except for exit if that happens (if you really know what you're doing and think you're program can continue, you might want to include logic to try and continue but keep in mind that some other code might want to allocate memory including some library calls which might be much less tolerate of a malloc() failure).</p>
<p>Complimentary function to malloc is <a href="https://linux.die.net/man/3/malloc">free</a>() which takes a pointer returned by malloc() and takes that memory "back" for re-use by the program potentially as the return from a future malloc() call.</p>
<p><em>Important note</em>: Malloc() returns a pointer - when you all free(), you want to pass that <em>exact</em> pointer value back.</p>
<p>Behind the scenes, there is a memory management routine running that allocates memory for your program in bigger chunks. This is typically referred to as the <em>heap</em>. The malloc() routine keeps a list of memory addresses it handed out and how big of an area that pointer was associated with. If you look at the documentation for the calls to malloc(), you'll see it's pretty much an all or nothing interface as you either get a pointer back meaning you got what you asked for or you get back nothing. Likewise, when you call free() with a pointer value you got from a malloc() call, you're also not passing the size of the amount of memory you're freeing, just a pointer to it. The free routines looks into a list of pointers that were already handed out, which include how much memory that pointer was pointing to, and marks it internally as being available. If you pass a different value, you really gum up the works. In the pro world, we refer to that as <em>heap corruption</em> and done enough times (or honestly just once), it messes up the lists this library call uses to track, manage, and return memory to the point where it could lose track of some memory (creating a dreaded <em>leak</em>) or even worse, it could give out some memory <em>twice</em> causing some very, very, very hard to find find data corruption bugs (imagine you had two variables, <b>x</b> and <b>y</b> and somehow they ended up overlapping the memory used to store what you thought were two very simple, completely distinct variables and when you updated one, you subtly altered the value of the other in a program section far, far away. That will be <em>very</em> tough to find.</p>
<p>So the pro tip of the day: make sure you give back what you got, and only what you got, and only once (because free()ing something more than once will also lead to *heap corruption).</p>
<p>Some resources for learning more about C memory management:</p>
<ul>
<li><a href="https://www.tutorialspoint.com/cprogramming/c_memory_management.htm">C - Memory Management</a></li>
<li><a href="https://www.tutorialcup.com/cprogramming/memory-management.htm">Memory Management in C Programming</a></li>
<li><a href="https://stackoverflow.com/questions/24891/c-memory-management">C Memory Management</a></li>
</ul>
<p>This might all seem like a giant pain but it really isn't; you actually learn to better appreciate how memory is actually managed and used so even in environments with garbage collection, you'll create less garbage (the big downside of automatic garbage collection is that when the environment needs to do it, you're program essentially freezes - not good for situation where you are controlling something in real time; like say, a robot. Stop processing events on or around your robot at seemingly random times for random amounts of time? Hello Mr. Wall or have a nice broken part because you sent a command to move something and weren't able to read the limit switch to stop from breaking something on your robot. Not good.</p>
<h3>Sockets and Networking</h3>
<h3>Multi-threaded Programming</h3>
<h3>Recursion</h3>
<ul>
<li><a href="https://www.tutorialspoint.com/cprogramming/c_recursion.htm">C - Recursion</a></li>
</ul>
<h3>Locks and Mutexes</h3>
<p>First off, you need to know how to pronounce "mutex" (syllable break between the "u" and the "t") - check out how "Julia" pronounces it at <a href="https://www.definitions.net/pronounce/mutex">Definitions.net</a> - listen <em>ONLY</em> to Julia, everyone else is pronouncing it, well, <em>WRONG</em> (OK, "Oliver" and "Emily" are pretty solid too but skip the US English dudes for sure as they clearly are not programmers).</p>
<p>Mu-tex - OK, now we can move on.</p>
<h2>Conclusion</h2>
<p>There is a lot going on in this design and corresponding code. Depending on your level of experience with C and the Linux environment, this might be the most complicated code you've dealt with to date. Don't hesitate to search for and read about some of the topics to learn more; also don't hesitate to ask me to help explain something as I'll be glad to do so. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
